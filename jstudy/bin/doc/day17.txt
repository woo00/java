# day17

final 속성 == 더 이상 수정 못 하게 함

	1. final class
		==> 이 클래스는 더 이상 상속이 불가능
			기능을 추가하거나 변경하지 않고
			현재 기능 그대로 사용하라는 의미.
		
	2. final 함수
		==> 이 함수는 오버라이드가 불가능한 함수
			따라서 이 함수는 매우 중요한 함수임
			함부로 기능을 바꾸지말고 현재 기능 그대로 사용하라는 의미.
		
	3. final 변수
		==> 이 변수는 값을 수정할 수 없는 변수
			즉, 현재 값을 유지해야하는 변수
			==> 상수
			
-----------------------------------------------------------------------------

추상 클래스
==> 추상 함수를 0개 이상 가지고 있는 클래스
	즉, 추상함수가 없어도 강제로 추상클래스를 만들 수 있고
	추상함수가 1개라도 존재하면 무조건 추상클래스임.
	
	추상함수란?
	==> 함수의 몸체(블럭)가 없는 함수.
		즉, 기능이 없는(정해지지 않은) 함수임.
		
	형식 ]
	
		[접근지정자] [속성] abstract 타입 함수이름(매개변수리스트);
		
	예 ]
		public abstract void abc(int a);

		
추상 클래스 만드는형식

	[접근지정자] abstract class 클래스이름 {
		[추상함수]
		일반함수
		멤버변수
	}
	
왜 씀??
	다형성 구현을 하기 위해서...
	
추상클래스 사용하는 방법
==> 추상클래스는 new 시킬 수 없다.
	그 안에는 기능이 없는(구현안된, 실체가 없는) 함수가 존재하기 때문이다.
	
	1. 다른 클래스에 상속을 해준 후 
		추상 함수의 기능을 만들어주고 (오버라이드)
		하위 클래스(상속받은 클래스)를 new 시켜서
		추상클래스의 변수에 기억시켜 사용.
		==> 실무에서 사용하는경우 10%미만임..
	
	2. 소속 함수중 반환값 타입이 클래스 자기자신이고 속성이 static 함수를 호출해서 사용
	
-----------------------------------------------------------------------------	
	
참고 ]
	추상 클래스가 아님에도 불구하고 
	생성자함수가 존재하지 않는 클래스가 있다.
	이 경우는 생성자가 없는 것이 아닌 생성자의 접근지정자를 private으로 은닉한 것.
	따라서, new 시켜서 인스턴스 생성이 불가능,
	클래스 역시
		속성이 static 이면서
		반환값 타입이 클래스 자기자신인
	함수를 찾아 호출해주면 된다.	
	
-----------------------------------------------------------------------------	
	
인터페이스(Interface)
==> 클래스의 한 종류이긴 하지만 그 형태나 의미가 다른 특수한 클래스의 일종.
	
	1. 최상위 클래스가 Object가 아님. = Object하위가 아님.
		==> 다른 클래스를 상속받아 만들어진 클래스가 아님.	
	
	2. 내부에는 100% 추상함수가 존재해야됨.
		==> 절대로 일반함수는(블럭이 있는함수/기능을 가진 함수) 존재하지 않는다.
		
		참고 ]
			인터페이스에서는 함수를 정의할 때
			abstract 속성을 부여하지 않아도 자동적으로 public abstract 속성이 부여됨.
			
			public abstract 타입 함수이름(매개변수리스트); // 추상함수 작성법
			==> 인터페이스에서는 
				타입 함수이름(매개변수리스트);  // 로 작성가능
				
	3. 인터페이스는 다른 클래스에 다중상속이 가능하다. 
	
	4. 변수는 가질 수 있다. 이 변수들은 암묵적으로
		public static final 변수가 된다.
		
	5. 인터페이스 소속 함수는 암묵적으로 public 함수가 됨.
	
참고 ]
	인터페이스 내에 일반함수(블럭이 있는함수)를 사용가능
	이 경우엔 반드시 함수의 속성을 
		default
	라고 명시해야함	
	
	형식 ]
		default 반환값타입 함수이름(매개변수리스트){
			함수내용...
		}	
		
인터페이스 제작방법
	접근지정자 interface 인터페이스이름{
		public static final 타입 변수이름 = 데이터;
		타입 함수이름(매개변수리스트);
	}
	
만들어 놓은 이유는??
==> 가끔은 JVM에 의해서 자동 호출되어야 하는 함수가 필요함.

	함수의 존재는 필요한데 그 함수가 해야할 일을 개발자가 정해야할 경우가 있음.
	
	따라서 기능은 개발자의 몫.
	
인터페이스 사용방법

	1.
		1) 인터페이스는 내부에 기능이 정의되지 않은 함수가 존재하기 때문에 new시킬 수 없음.
			
			따라서 일반 클래스에 상속해준 후 그 클래스를 new 시켜서 사용해야함.
			
				상속해주는 방법 ]
				
					접근지정자 속성 class 클래스이름 implements 인터페이스 {
						추상함수 오버라이드작업
					}
				
				참고 ]
					클래스를 상속 받는 것은 "상속"이라고 표현하고 		extends
					인터페이스를 상속 받는 것은 "구현"이라고 표현한다.	implements
					
		2) 상속받은 클래스에서는 인터페이스 안에 있는 
			모든 함수를 100% 오버라이드해야함.
			==> 내용을 정하지 못 할 경우엔 블럭만이라도 달아줘야함.
			
			인터페이스 소속함수의 접근지정자는 public이다.
				
		3) 구현한 일반 클래스를 new 시켜서 사용하면 됨.
		
	2.
		함수 중 속성이 static이면서 반환값 타입이 자기자신인 함수를 호출해서 사용.
		인터페이스의 경우 이런 함수를 자기 자신이 가지지 않고
		다른 클래스에 이런 함수가 존재하기 때문에 찾아서 사용해야함.

인터페이스의 다중상속 형식]

	class 클래스 이름 implements 인터페이스1, 인터페이스2,...{
		인터페이스들이 가진 추상함수는 모두 100% 오버라이드해야함.
	}
	
참고 ]
	일반 상속과 인터페이스 구현을 동시에 사용할 수 있다.
	단, 일반 상속이 먼저 기술되어야함.
	
	형식 ]
	
	class 클래스이름 extends 상속해줄클래스 implements 인터페이스1, 인터페이스2...{
		추상함수는 모두 100% 오버라이드 
	}	

참고 ]
	인터페이스는 다른 인터페이스를 상속받아서 만들 수 있다.
	
	형식 ]
		interface 인터페이스 이름 extends 인터페이스 {
		}
	
		주의 ]
			인터페이스를 상속받아서 인터페이스를 만드는 경우는
			implements 가 아니고 extends 이다.
	
-----------------------------------------------------------------------------