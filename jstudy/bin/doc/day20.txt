# day20

1. emp1 테이블에서 부서번호를 입력하면
	해당 부서 소속의 사원들의
		사원번호, 사원이름, 직급, 급여
	을 조회하는 기능
	
	제어하는 기능 추가
		
		1. 이름으로 조회
			--> 이름리스트 출력
			--> 이름 입력창 실행
			--> 입력받은 이름으로 데이터 조회
			
		2. 부서번호로 조회
			--> 부서번호 리스트 출력
			--> 부서번호 입력창 실행
			--> 부서번호 입력받아서 데이터 조회
		
		3. wooyoung사원 입사정보 입력
			사원번호 	: 서브질의
			사원이름 	: wooyoung
			직급		: MANAGER
			상사번호	: SMITH 사원번호
			입사일		: 오늘(시간빼고)
			급여		: 500
			커미션		: -500
			부서번호	: SMITH의 부서번호
			메일		: wooyoung@githrd.com
			
		4. wooyoung 사원의 급여를 99999로 수정.

숙제 ]
	4번 기능을 
		1. 이름을 입력하면 이름에 해당하는 사원들의
			사원번호, 사원이름, 급여, 입사일, 부서번호
			를 출력해주는 기능 추가 
			
		2. 출력된 사원의 사원번호와 급여를 입력해서 
			사원의 급여를 수정해주는 기능 구현
			
--------------------------------------------------------------------			

Set계열
==> 
	특징 ]
		1. 입력순서를 보장하지 않음.
			==> 나름의 규칙을 가지고 내부적으로 정렬을 해서 보관.
			
		2. 중복데이터를 허용하지 않는다.
			==> 같은 데이터가 다시 저장되면 
				먼저 데이터는 지우고 새로운 데이터를 입력한다.
		
		***
		Set계열은 데이터의 위치를 개발자가 알 수 없으므로 
		데이터를 꺼내는 함수가 없다.
		기억된 데이터를 추출하려면 
			Iterator || List계열
		로 변환해서 순차적으로 꺼내서 사용해야한다.
	종류 ]
		1. HashSet
			==> HashCode를 이용하여 정렬해서 보관하는 방식
				우리가 생각하는 정렬은 이루어지지 않는다.
								
		2. TreeSet
			==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능.
			
				특징 ]
					우리가 생각하는 정렬방식을 이용.
					
					***
					정렬가능한 객체들만 기억가능.
					
				생성자 ]
					TreeSet(Comparator comparator)
					==> 정렬방식을 지정해서 TreeSet을 만든다.
					
					TreeSet(SortedSet<E> s)
					==> TreeSet을 이용해서 다시 TreeSet을 만드는 방법
				
				참고 함수 ]
				
					subSet()
					==> 하나의 Set에 담긴 내용중에서 특정 부분만 골라서 새로운 Set을 만드는 함수 
					
					headSet(E toElement)
					==> 처음부터 지정한 부분까지 새로운 Set을 만든다.
					
					tailSet(E fromElement)
					==> 지정한 부분부터 마지막까지 새로운 Set을 만든다.
					
----------------------------------------------------------------------------------------------------------------------------------------

Map
==> 하나의 데이터를 키값과 한 쌍으로 만들어서 데이터를 기억하는 컬렉션 					
	키값을 이용해서 데이터를 꺼낼 수 있음.
	
	많은 양의 데이터를 보관하는 용도보단 
	데이터를 쉽게 구분하여 사용할 목적.

HashMap / HashTable
==>
	HashTable이 이전 버전,
	HashMap이 최신 버전. ==> 사용권장.
	
	내부적으로 키값을 해쉬테이블을 이용,정렬해서 보관
	
	주요함수 ]
		put(Object key, Object value)
		==> 데이터 입력함수
		get(Object key)
		==> 데이터 꺼내는 함수
		
	참고함수 ]
		values()
		==> 데이터들만 꺼내는 함수
			예 ]
				HashMap map = ...;
				
				Collection col = map.values();
				
				1.
					Iterator itor = col.iterator();
				2.
					ArrayList list = new ArrayList(col);
				
		keys() | keySet()
		==> 키값들만 꺼내주는 함수
		
			Enumeration<K> keys()
			참고 ]
				Enumeration : Iterator의 구버전.
								데이터를 순차적으로 꺼내어 사용해야함.
								
			Set<K> keySet()
			==> 키값들만 추출해서 Set으로 반환해주는 함수
			
			참고 ]
				HashMap에는 키값만 추출하는 함수가 keySet()만 있다.
				
			참고 ]
				entrySet()
				==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
					(위의 함수들을 사용하면 다른 방법으로도 꺼낼 수 있다.)
					==> 키값과 데이터를 VO에 담아서 Set으로 묶어주는 함수
					
						Set<Map.Entry>
						==> Set<VO> // VO : key, value 변수와 getters & setters 함수만 가지고있다.
						
						HashMap map = new HashMap();
						
						map.put("one", 1);
						map.put("two", 2);
						map.put("three", 3);
						
						Map.Entry
						=	VO {
								private Object key;
								private Object value;
								...
							}
							
						Map은 항상 키와 밸류가 있어야 저장됨.
						Set은 오직 한개만 저장할 수 있다.
						따라서, 키와 밸류를 하나로 묶어야만 Set에 기억시킬 수 있음.
						
						이것을 해결하기 위한 VO클래스가 Map.Entry 클래스임.
						이 클래스는 내부에 key와 value라는 변수를 은닉화 시켜서 가지고 있는 클래스임.
						데이터를 입력하는 함수와 채우는 함수도 만들어 놓았다.
						
TreeMap
==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
	이 때 정렬기준은 키값을 이용해서 정렬.
	따라서, 키값의 크기가 비교가능한 데이터여야 입력가능.
	
	필요하면 정렬기준을 정해서 사용가능.
참고 ]
	컬렉션 안에는 모든 클래스를 입력할 수 있으므로, 컬렉션안에는 다시 컬렉션이 입력될 수 있다.
	