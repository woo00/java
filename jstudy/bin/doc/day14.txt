#day 14

*****
함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스 안에서는 함수의 이름은 모두 달라야한다.
	같은 클래스 안에서 같은 이름의 함수가 존재하면 오류발생.
	
	가독성에 있어서 문제가 발생할 수 있음.
	즉, 함수의 가독성이란?
	이름만 봐도 그 함수가 어떤 역할을 하는 함수인지 알아야하는데 
	함수의 이름을 모두 다르게 만들면 
	가독성에 있어서 문제가 발생할 수 있다.
	
	이 문제를 해결하기 위해서 도입된 문법이
		함수의 오버로딩
	이다.
	
	오버로딩이란?
	같은 클래스안에 같은 이름의 함수를 만들 수 있다.
	단, 다음 조건을 반드시 지켜야만 한다.
	
	***
	오버로딩 조건 ]
	
		0. 만들려는 함수의 이름이 같은 클래스 내에 존재해야한다.	
		1. 함수의 이름은 같아야함.
		2. 매개변수의 개수, 순서, 형태 중 하나 이상이 달라야 한다.
			참고 ]
				void abc(int a, int b){}
				void abc(int b, int a){}
		3. 반환값 타입과는 전혀 상관없다.
		
		예 ]
			void abc(){}
			void abc(int a){} 			==> O
			void abc(float a){} 		==> O
			void abc(int a, int b){}	==> O
			void abc(int a, float b){}	==> O
			void abc(float a, int b){}	==> O
			void abc(int b, int a){}	==> X
			
	결론 ]
		함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야한다.
		
		예 ]
			void abc(){
				(1)
			}		
			
			void abc(int a){
				(2)
			}		
				abc(); 		==> (1) 실행
				abc(10); 	==> (2) 실행
		
	사용방법
		다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수있다.
		이들 함수를 사용하는 방법
		
		원하는 기능의 함수가 요구하는 데이터를 
		형태와 순서에 맞춰 정확하게 지정한다.	
		
		참고 ]
			형태가 맞지 않더라도 자동 형변환이 되어 실행되는 경우가 있다.
					
			예 ]
				void abc(){
					(1)
				}		
				
				void abc(int a){
					(2)
				}		
				void abc(double a, int b){
					(3)
				}
				
				abc();		==> (1)
				abc(10);	==> (2)	
				abc(5, 10); ==>	(3)
					<== double a; int b;
							a = 5; ==> 자동형변환
							b = 10;

==========================================================================================			
객체지향 프로그램(Object Oriented Programming : OOP)
==> 클래스를 이용해서 프로그램을 만들어 나가는 언어 

클래스란?
==> 하나의 목적을 달성하기 위해서 필요한 기능을 모아놓은 
	프로그램의 기본단위
	
	예 ]
		문자열을 관리해야겠다
		==> String
		
		네트워크를 처리해야겠다.
		==> Socket
		
		많은 양의 데이터를 한꺼번에 보관하고 관리하겠다.
		==> ArrayList
		
	따라서 클래스의 구성요소는
		1. 변수	: 필요한 데이터를 보관하고 있어야함.
				멤버변수라고도 부르며 다른말로 Field라고 부르기도 한다.
				
		2. 함수 : 목적을 해결하기 위한 기능이 있어야한다.
				멤버 함수라고도 하고 Method라고 한다.
				
				
				
	클래스 제작 방법
	
		[접근지정자] [속성] class 클래스이름 {
			변수
			함수
		}
	
	***
	문제는 이 클래스는 설계도에 불과하다.
	클래스만 가지고 있다고 해서 실행되는 것은 아니다.
	클래스가 실행 가능하게 되어야한다.

	이처럼 클래스를 실행 가능한 물건으로 만든 것을 
		Object
	라고한다.
	
	결론적으로 
	객체지향 언어는 클래스를 기반으로 해서 만들어진 Object에 의해서
	만들어지는 프로그램
	
	객체(Object)를 만드는 방법 ]
	==> 객체는 JVM이 만들어준다.
		다만 개발자는 필요한 부품을 만들어 달라고 명령만 내리면 된다.
		
		명령 ]
			클래스이름 변수;
			변수 = new 클래스이름();
			
		예 ]
			Test라는 클래스가 존재한다면
			
			Test t;
			==> t 변수는 레퍼런스 변수가 된다. 이 변수의 heap type Test
			t = new Test();
			==> new 명령을 통해서 클래스가 Object가 된다.
				컴퓨터가 물건을 만든다는 개념은
				메모리에 클래스가 만들어진다는 개념
				
			따라서 heap에 만들어진 클래스르 instance라 부르고 
			만들어진 Instance 의 주소를 기억하는 변수를 
			reference 라고 부른다.
			
			instance 와 reference 를 통칭해서 Object (객체) 라고 한다.

		예 ]
			class Test {
				int no; // 멤버변수
				public int plus(int no1, int no2){
					return no1 + no2;
				}
			}
			
			Test t;
			t = new Test();
			
			int num = t.no;  // 변수사용
			int result = t.plus(10, 20);

객체 사용방법
==> 객체를 사요한다는 것은
	그 목적을 달성하기 위해서 필요한 데이터(변수)를 기억하던지
	그 목적을 달성하기 위해서 필요한 기능(함수)을 이용하는 것.

	사용방법 ]
		
		주소.변수
		주소.함수();

	참고 ] 
		자바에서는 소속을 밝힐 목적으로 사용하는 기호는 .만 사용한다.

	참고 ]
		클래스 하나당 오브젝트는 여러개 만들어도 상관없다.
		주소를 이용해서 사용하게 되므로 
		각각의 오브젝트는 별개로 독립되어서 실행 될 수 있다.

참고 ] 
	지역변수
	==> 해당 영역에서만 사용가능한 변수
		변수 선언문이 실행되는 순간 변수가 만들어지고
		그 블럭을 벗어나면 그 변수는 사라지게 된다.
	
	전역변수
	==> 모든 영역에서 사용할 수 있는 변수
		클래스 안에서 만들어진 변수.
		왜냐하면 클래스 안에서 만들어진 변수는
		new 시키는 순간 Heap 영역에 만들어지기 때문에
		Heap 영역의 특성에 따라서 계속 사용할 수 있게 된다.
		
		탄생시점 : new 시키는 순간
		소멸시점 : 프로그램이 종료되는 순간
		
=================================================================================		
	
객체의 배열
==> 하나의 클래스를 이용해서 여러개의 오브젝트 (객체)를 만들 수 있으므로
	배열로 만들어 관리할 수 있다.
	
	만드는 방법 ]
	
		Test[] t;
		==> Test객체를 배열로 관리할 주소를 기억할 변수
		
		t = new Test[개수];
		==> 관리할 공간만 확보한 null로 채워진 상태.
		
		
		t[0] = new Test(); // 첫번째방에 Test 객체 기억
		t[1] = new Test(); // 두번째방에 Test 객체 기억
		...
		
	사용방법 ]
	
		배열변수[위치값].변수이름 = ???;
		
		변수 = 배열변수[위치값].변수이름;
		
=================================================================================		
		

생성자함수(Constructor)
==> 클래스를 사용하기 위하여 new 시키는 순간 자동 실행되는 함수
	(new 명령과 함께 같이 호출되는 함수...)
	
	즉, 클래스를 new 시킨다는 것은 
	오브젝트로 만들어서 실행한다는 것이다.
	따라서 이때 실행한다는 것은 결국
	오브젝트를 만드는 순간에 뭔가를 실행한다는 개념이다.
	
	이것은 물건을 만들때 필요한 뭔가 조치를 한다는 것이다.
	==> 결론적으로 물건을 실제로 만들기 위한 함수...
	
	
	클래스는 한가지 목적을 달성하기 위해서 만들어지는 프로그램 단위
	이 안에는 그 목적을 달성하기 위한 변수, 함수로 구성된다.
	하지만 그 목적을 달성하기 위해서는 가장 기본적인 어떤 조치가 필요한 경우가 있을 것이다.
	
	예 ]
		String 
		==> 문자열을 관리하기 위한 목적으로 만들어진 클래스
			===> 문자열을 기억하고 있어야 한다.
			
		FileOutputStream
		==> 파일에 내용을 기록하기 위한 목적으로 만들어진 클래스
			==> 파일을 사용할 수 있도록 파일과 연결되어 있어야 할 것이다.
			
		Socket
		==> 네트워크를 구성하기 위한 목적으로 만들어진 클래스
			==> 상대방과 접속은 이루어져 있어야 한다.
			
	프로그램은 프로그램답게 뭔가를 처리하기 위해서는 함수 필요하고...
	위의 경우에 비추어보면 각각의 클래스는 오브젝트로 만들어지는 순간
	그 클래스 만의 최소의 일을 할 필요가 있다.
	
	바로 이런일을 하기 위해 만들어 놓는 함수가
		"생성자 함수(Constructor)"
	라고 부른다.
	
	
	정리 ]
		생성자 함수를 만드는 이유는
		만들고자하는 클래스의 목적에 따라
		그 클래스가 해야 할 가장 기본적인 일을 처리하기 위해 만드는 것이다.
		
생성자 함수 만드는 방법 ]

	규칙 ]
		1. 	함수의 이름은 반드시 클래스 이름과 대소문자까지 동일
		2.	반환값을 절대로 가지면 안됨. void 금지
		3. 	매개변수는 가질 수 있다.
			==> 매개변수 리스트를 다양하게 구성해서 오버로딩 할 수 있다.
		
		예 ]
			class Test{
				Test(){
					// 기본 생성자함수
					// 이 안에 이 클래스가 해야할 가장 기본적인 내용을 코딩
				}
				Test(int a){ // 생성자. 
				
				}
				void Test(){ // 생성자가 아닌 일반함수가 된다
				}
			}
		
		참고 ] 
			생성자 함수는 오버로딩이 가능.
			==> 생성자 함수는 여러개 만들 수 있다. (매개변수리스트의 형태에 따라서...)
	
			여러개의 생성자 함수가 있다는 것은
			new 시킬 때 필요한 생성자 함수가 여러개가 된다는 것
			상황에 따라 필요한 생성자 함수를 선택할 수 있어야 된다는 것
			이 때 기준은 준비된 데이터에 따라서 결정될 것
	
		결론적으로
			매개변수가 있는 생성자 함수를 호출하기 위해서는
			new 시킬 때 매개변수에 필요한 데이터를 주면 됨.
	
	***
	자바는 생성자 함수가 없어도 new 될 수 있다.
	이것은 생성자 함수를 이용하지 않는것이 아니라
	JVM이 기본 생성자를 내부적으로 만들어 준 후 이용한다.
	
	결론적으로 자바는 new 시킬 때 반드시 생성자 함수를 이용해야한다.
	
	*****
	만약 개발자가 생성자 함수를 단 한 개라도 정의하게(만들면) 되면
	JVM은 기본생성자를 만들어주지 않음.
	
	즉,  내부적으로 기본생성자를 만드는 경우는
	오직 개발자가 생성자함수를 단 한 개라도 만들지 않았을 경우임.
	
	
	참고 ]
	
	선생님 : 생성자를 정의하게 되면 내용이 없더라도 기본생성자도 정의해주세요

생성자 함수 이용방법
==> 생성자 함수는 그 클래스를 어떻게 new 시킬지 알려주는 함수.
	==> 그 클래스를 어떻게 인스턴스로 만들 수 있는지를 알려주는 함수 
	
	예 ]
		class Test {
			public Test(){
			}
			
			public Test(int a){
			} 정수하나가 준비된 경우
			
			public Test(double a) {
			}실수 하나가 준비된 경우
			
			public Test(String s)
			} 문자열 하나가 준비된 경우
			
			public Test(int[] arr){
			} 정수 배열 하나가 준비된 경우
		}

	생성자 함수가 요구하는 매개변수가 무엇인가를 보면
	그 클래스를 인스턴트화 시킬 수 있는 방법이 나온다.
	
=================================================================================		
	
this()
==> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.

	현재 생성자를 실행하는 도중에 다른 유형의 생성자를 강제로 호출할 수 있는 유일한 방법
	
	
	***
	규칙 ]
		1. 반드시 생성자 함수 내에서만 사용가능.
		
		2. 반드시 생성자 함수 첫 문장으로 와야함.