# day12

참고 ]
	다차원 배열의 경우
	내부의 배열의 길이는 모두 달라도 된다.
	
	형식 ]
		
		int[][] arr = new int[5][];
		
		arr[0]={1,2,3};
		arr[1]={1,2,3,4,5};
		
-------------------------------------------------------------------------------

배열의 단점 ]
	1. 한 번 배열의 크기가 정해지면 크기 조절이 불가능하다.
		예 ]
			int[] num = new int[10];
			==> num이라는 배열을 생성, 이 배열은 정수 열개를 관리할 배열이라는 의미
			
			여기서 데이터가 더 추가되어야 할 때 이미 생성된 배열로는 불가능,
			추가될 갯수만큼의 배열을 만들어서 관리.
			
			int[] tmp = num;
			
			num = new int[11];
				의 작업으로 배열을 다시 만들고 
				기존데이터를 깊은 복사해서 사용.
				
				System.arraycopy(tmp, 0, num, 0, 10);

				num[10] = 100;
				
	2. 같은 타입의 데이터만 관리할 수 있다.
		==> 주소는 Heap 타입에 의해서 결정되고 Heap 타입이 다르면 사용할 수 없다.
		
		int[] no;
		
		no = new float[10];
		no = new String[10];
		==> Heap 타입이 다르기때문에 변수가 인스턴스의 주소를 기억할 수 없다.
		
	<== 배열 만드는 형식 ] 
		데이터타입[] 변수 = new 데이터타입[개수];	
		
		==> 배열은 만들 때
		
-------------------------------------------------------------------------------

String 배열
	참고 ] 
		String 역시 주소 변수
		
		String str = "jennie";
		
			str에는 리터럴풀의 제니 주소가 기억됨
		
		String str1 = new String("jennie");
			
			str1에는 힙에 만들어진 String의 인스턴스의 주소가 기억됨 
			그 인스턴스안에서 리터럴풀의 주소를 참조하게됨.
			
	참고 ]
		래퍼런스 변수란?  ex) 59번줄의 str1
		==> 인스턴스의 주소를 기억하는 변수
		
			하지만 프로그램에서는 주소는 필요없고 오직 데이터만 필요하다.
			주소변수는 데이터가 존재하는 위치를 알려줄 뿐이고,
			데이터가 들어갈 메모리, 실제 데이터가 핵심이다.

String 배열 만들기

	String[] 변수이름;				==> 변수선언
	변수이름 = new String[개수];	==> 배열이 관리할 데이터의 공간만 확보한 상태
	
		문자열 배열의 경우는 데이터를 바로 대입해줄 수 있다.
		각 방에 접근해서 문자열을 대입해주면 사용가능.	
	
	String 배열도 초기화가 가능
	
	예 ] 
	
		String[] asd = {"a","b","c","d"};
		String[] asd = new String[]{"a","b","c","d"};
	
-------------------------------------------------------------------------------

참고 ]
	String은 필요에 따라 char[] 형태로 변환해서 사용할 수 있다.
	
	사용함수 ] 
		문자열.toCharArray();	
		
	예 ]
		String name = "jennie";
		char[] jeny = name.toCharArray();
		
		jeny[0] ==> 'j'
		jeny[5] ==> 'e'
		
참고 ]
	String 클래스에서 자주 사용되는 함수
		
		1. charAt(위치값)	==> 해당 위치의 문자를 반환해주는 함수
		2. length()			==> 문자열의 길이를 반환해주는 함수
		3. substring()	
			==> 문자열 중에서 원하는 문자열만 추출해서 반환해주는 함수
			
		형식 1]		
			substring(시작위치)
			==> 시작위치에서부터 문자열의 끝까지 추출
			
		형식 2 ]
			substring(시작위치, 종료위치)
			==> 시작위치에서부터 종료위치 이전까지 추출
			
		참고 ]
			시작위치는 0부터 시작하고
			종료위치는 1부터 카운트해서 지정할 수 있다.
			
	4. equals()
		==> 문자열의 데이터가 같은지 비교해주는 함수
		
			형식 ]
				문자열1.equals(문자열2)
				==>
					반환값은 논리형(true||false)으로 반환된다.

-------------------------------------------------------------------------------

2차원 배열
==> 1차원 배열을 다시 배열로 관리

만드는 방법 ]
	1. 배열의 주소를 기억할 변수 생성 ==> Heap영역에 있는 데이터는 주소를 알아야 사용가능하다.
	
		방법 ]
		
		데이터타입[][] 변수이름;
		
		예 ]
			int [][] nums;
			
	2. 1차원배열을 몇개 관리할지 결정하고 주소를 기억할 메모리를 생성.
	
		방법 ]
		
			변수 = new 데이터타입[개수][]; ==> 개수는 1차원배열의 개수를 의미.
			
		예 ]
			nums = new int[2][];
			
	3. 실제 데이터를 기억할 1차원 배열을 만들어준다.
		
		방법 ]
			변수[위치값] = new 데이터 타입[개수];
			
		예 ]
			nums[0] = new int[5];
		
	참고 ]
		Heap Type
		==> 주소가 가리키는 곳에 있는 데이터의 형태를 지정하는 용어
			인스턴스는 Heap에 만들어진다.
		==> 같은 Heap Type 끼리만 사용가능
		==> 차원 역시 같아야함.
		
		int[]no = new int [5];
		==> Heap Type은 no 라는 변수의 주소가 가리키는 곳의 
			인스턴스의 형태는 1차원 배열이다.
			==> Heap Type은 1차원 정수 배열이 된다.
			
	참고 ]
		사각형의 형태의 배열도 만들 수 있다.
		
		형식 ]
		 데이터타입[][] 변수 = new 데이터타입[개수1][개수2];
		 ==> 데이터베이스의 테이블로 비유하자면 
		 	개수1은 행,  개수2는 열에 해당.
		 	
	 	예 ] 
	 		int[][] no = new int[3][5];
	 		==> 3행짜리 5열의 데이터를 가지는 사각형 형태의 배열이 생성됨
	 		
	참고 ]
		2차원 배열도 초기화가 가능하다.
		
		 방법 ]
		 	int[] num = {}; // 1차원 배열 초기화
		 	int[][] no = {{1,2,3},{4,5},{6,7,8}};
		 	
	 	참고 ]
	 		여기서도 배열의 개수는 지정할 수 없음.
	 		1차원배열과 마찬가지로 
		
			