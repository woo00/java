# day05

자바 프로그램의 토큰 구분
==> 컴파일러는 토큰단위로 번역을 시도한다.
	따라서 개발자는 컴파일러가 번역을 하는 토큰 구분을 해줘야한다.
	이것이 ";"라는 기호를 이용해서 구분된다.
	
	우리가 습관적으로
		int a = 10;
	이라고 세미콜론을 추가한 이유가
	토큰을 구분하기 위한 기호였기 때문이다.
	
	결론적으로 토큰은
	하나의 명령이 종료되었음을 알려주는 기호다.
	
	만약 개발자가 토큰 구분을 하지 않으면 오류가 날 수 있다.
	
	예 ]
		 int no1 = 10
		 int no2 = 20;
		 ==> 컴파일러는 두 줄을 하나의 명령으로 인식해서
		 처리를 시도할 것,
		 이런 명령형식은 존재하지 않으므로 에러발생
		 
		 ==> 수정 
		 int no1 = 10; int no2 = 20;
		 
	 참고 ] 
	 	; 대신 중괄호 {} 가 그 역할을 대신 할 수 있다.
	 	
	 	예 ]
	 	
	 		if(조건식) {
	 			내용
	 		} << 이부분에서 토큰발생
	 		
	참고 ]
		정수형태의 문자열을 실제 정수로 변환시키는 방법
		
			"123" ==> 출력하면 숫자처럼 보이지만 데이터의 형태는 문자열.
					이 문자열을 정수로 바꾸지 않으면 산술연산 불가능
			
			정수로 바꾸는 방법
			
			형식 ]
				int 변수이름 = integer.parseInt(숫자형태문자열데이터);
				int no = integer.parseInt("123");
			
-------------------------------------------------------------------------------------------------

연산자의 우선순위

==> 하나의 연산식에서 여러 연산자가 혼용되어 사용되는경우
	어떤것을 먼저 처리해야하는지 정해놓은 규칙
	
	규칙 ] 
		산술	>	비교	>	논리	>	대입			
	
		예 ] 
			no > 10 & no < 20
			의 경우 연산 방향대로 왼쪽에서 오른쪽으로 순차적처리가 아닌
			먼저 왼쪽에 있는 비교연산자를 우선 연산하고 
			오른쪽의 비교연산자를 연산 후 
			논리연산자를 연산.
			
------------------------------------------------------------------------------------------------			

증감연산자
==> 주기억장치에서 직접 연산되는 연산자
	대입하지 않아도 변수자체가 변경됨.
	
	기호 ]
	++
	--
	
	의미 ]
		변수의 데이터를 1씩 증가||감소 시키세요.
		(연산기호 다음에 오는 변수에 데이터를 증감)
	
	예 ]
		int no1 = 10;
		no1++;
		==>		no1 : 10,  이 후에 오는 no1에 +1해서 11로 기억
		
		int no2 = 20;
		--no2;
		==> --연산자 다음에 바로 no2가 오기때문에 no2를 -1해서 
		19로 기억
		
	주의 ]
		이 연산자는 다른 연산자와 혼합되어있는 경우
		(연산을 해야하는 데이터가 다른 연산자||명령 에도 사용되는 경우)
		
		하나의 식 안에 다른 연산자와 증감연산자가 같이 있는 경우
		다른 연산자의 실행순서가 달라질 수 있다 .
		즉,
			증감연산자가 먼저 실행될 수 있고 
			증감연산자가 나중에 실행 될 수 있다.
			
		예 ]
			b=++a;
				a변수는 증감.
				b에 기억시키세요
				
			이 경우 a는 둘 중 무엇을 먼저 실행할지 구분.
			
		종류 ]
			누구를 먼저 실행할지 명확하게 구분하기 위해 규칙이 생겼다
			
			선처리 증감
				형식 ]
					++데이터
					==> 증감을 먼저하고 다른 연산을 나중에
					
			후처리증감
				형식 ]
					데이터++
					==> 다른 연산을 먼저 수행하고 증감연산을 나중에하세요.
					
------------------------------------------------------------------------------------------------			

부호 반전 연산자
==> 현재의 부호를 반대로 바꿔주는 연산자
	즉, 현재 양수이면 음수로, 현재 음수이면 양수로 바꿔주는 연산자
	
	기호 ] 
		-
		
	형식 ]
	
		-데이터;
------------------------------------------------------------------------------------------------			
비교연산자 
==> 두 데이터의 크기를 비교하는 연산자
	
	기호 ]
		
		==	같다
		!=	다르다
		>	크다
		<	작다
		>=	크거나 같다
		<=	작거나 같다
	
	참고 ]
		사용되는 피연산자의 데이터에 관계없이 연산의 결과는 항상 논리값(true, false)이 발생
		
	참고 ]
		이 연산자는 주로, if, ... 등의 제어명령에서 질문이 필요할 때 사용.
		
	*****
	주의 ]
		문자열은 기본 데이터 타입이 아니다.
		따라서 문자열을 비교할 때 조심해서 사용해야한다.
		
		문자열을 기억할 때
			new String("문자열데이터")의 형식으로 하면 Heap에 기억이 되고
			"문자열데이터"의 형식으로 하면 리터럴풀에 기억.
			
		리터럴풀의 특징 ]
			1. 주소를 알아야 사용가능 
			2. 개발자가 입력한 데이터는 반드시 리터럴 풀에 저장
			3. 리터럴풀은 같은 데이터가 입력되면 저장하지 않고 
				먼저 입력된 데이터를 재사용하게 됨
				
		
		동등비교의 경우 데이터를 비교하는것이 아니고 
		주소를 비교하는 개념이다.
		
		문자열의 경우 데이터의 비교가 필요한 경우는
		String 클래스 소속의 equals()함수를 이용해서 비교.
	참고 ]
		산술 연산이 가능한 데이터는 자바에서는 기본형 데이터(논리형 제외)에서만 가능
------------------------------------------------------------------------------------------------			
논리연산자
==> 두 논리값 (true||flalse) 사이의 관계를 따지는 연산자
	==> 즉, 논리값을 AND, OR, NOT 방식으로 관계를 따짐
	
	주의사항 ]
		데이터(피연산자)는 반드시 논리값이어야 한다.
		
	기호 ]
		!		NOT 연산 (단항 연산자)
		&		AND 연산 (이항 연산자)
		|		OR	연산 (이항 연산자)
		&&		AND 절삭연산 (이항 연산자)
				==> AND 연산의 경우 두개의 피연산자가 모두 true인 경우에 한해서만 true 이다.
					따라서 앞의 데이터가 false인 경우는 뒤의 데이터까지 항상 false,
					따라서 이런경우는 뒤의 데이터를 읽지않아도 결과는 결정이됨.
		||		OR 	절삭연산 (이항 연산자)
				==> 앞의 데이터가 true 이면 뒤의 데이터상관없이 true
------------------------------------------------------------------------------------------------			
비트연산자
==>자바에서는 잘 사용하지 않음
	C언어에서 가지고 온 연산자
	C언어의 경우는 메모리 주소에 직접 접근과 이용 가능
	자바의 경우 메모리에 직접접근이 불가능
	
	숫자를 비트단위로 저장된 상태를 이용해서
	각 비트마다 따로 연산하는 연산자
	
	기호 ] 
		&	비트AND
		|	비트OR
		^	비트XOR
		
	가끔 시험문제로 출제되기도함
	논리연산자와 구분하는 방법
	
	피연산자가 숫자이면 비트연산자로 처리
		예 ] 
			10 & 20
	
	참고 ]
		비트연산의 결과는 항상 숫자로 나옴
		
		~	보수화 연산자 (단항 연산자)	
			==> 각각의 비트의 숫자를 반대로 바꿔주는 연산자.
------------------------------------------------------------------------------------------------			
쉬프트 연산자
	
	기호 ]
		>>
		<<
		
	의미] 각각의 비트를 지정한 방향으로 지정한 숫자만큼 이동시켜주는 연산자
	
	예 ]
		int a = 10;
		a = a << 2;
		
		10을 비트로 만들면 1010			
------------------------------------------------------------------------------------------------			
대입연산자
	==> 변수에 데이터를 기억시키기 위한 연산자
	
		주의 ] 연산된 결과는 대입연산자를 거치지 않으면 변수에 기억되지 않음
		
		기호 ]
			=
		
		형식 ]
		 	변수 = 데이터;
		 				여기서 데이터는		상수(입력한내용, 리터럴 데이터)
		 									연산식(연산 수행결과를 변수에 대입한다는 의미)
		 									변수
		
		예 ]
			a = 10;
			a = 10 << 2;
			a = b;
	참고 ]
		누적 대입연산자
		==> 특정 변수에 연산을 한 후에 다시 그 변수에 결과를 기억하는 경우
		
		예 ]
			a = a + 10;
			
			의 연산식을 줄여서 사용가능
			
		형식 ]
			변수	연산자 = 	데이터;
			<== 변수 = 변수	연산자	데이터;
			
		예 ]
			a = a + 10;
			==>
				a += 10;
			
			a = a >> 3;
				a >>= 3;				
------------------------------------------------------------------------------------------------			
3항 연산자(3항 조건 연산자)
==> 연산자보다는 명령에 가까운 형식을 가지고있음
	조건에 따라서 처리할 내용을 구분해서 처리하도록 하는 연산자.
	
	형식 ] 
		
		(조건식) ? 조건식이 참인경우 반환값 : 조건식이 거짓인경우 반환갑;
		
	주의 ]
		조건식은 반드시 참 또는 거짓의 결과가 만들어져야한다.
		
	if 명령을 단순화 시킨 명령이다.
	
	참고 ]
		모든연산자가 중첩처리 되듯이
		조건 연산자도 중첨처리될 수 있다.
		
		예]
			(조건식) ? 데이터1 : ((조건식2)? 데이터2 : 데이터3);