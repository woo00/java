#day16

상속
==> 이미 만들어져있는 클래스의 기능을 그랟로 부여받아
	(변수와 함수의 기능을 그대로 복사)
	새로운 클래스를 만드는 방법
	
	사용하는 이유 ?
	==> 소프트웨어의 개발속도를 빠르게 하기위한 방법
	
	즉, 상속은 객체지향에서 제일 중요한 역할
	
	객체지향언어는 부품단위(클래스)로 프로그램을 만든 후 
	그 부품들을 조립해서 원하는 결과를 만든다.
	
	어딘가에서 부품(클래스)을 구했는데 
	그 기능이 꼭 사용자 마음에 들진 않을 수 있다.
	따라서, 처음부터 다시 만들어야 하나? 라는 문제발생
	해결하기 위해 만든 방법이 상속.
	
	상속은 자신이 만들고자 하는 부품과 가장 비슷한 부품을 가지고 와서
	일단 그 기능을 모두 복사한 후 
		1. 없는 기능은 추가
		2. 있는 기능 중 내용 수정
	
	상속하는 형식 ]
	
	 [접근지정자] [속성] class 클래스이름 extends 상속해줄 클래스이름{
	 	현재 클래스에서는 상속받을 크래스가 가진 모든 기능은 이 내부에 복사되어 있다.
	 }
	 
	 참고 ]
	 	자바는 오직 단일 상속만 허락한다.
	 	즉, 상속은 오직 한개의 클래스에서만 받을 수 있다.
	 	
	 	예 ] 
	 		class NewClass extends OldClass01, OldClass02, OldClass03{
	 		
	 		} ================== 불가능
	 		
	 		class NewClass extends OldClass{
	 		} ================== 가능
	 		
	용어 ]
	
		상속을 해준 클래스 		- super Class, 상위 클래스(부모클래스)
		상속을 받은 클래스		- sub Class, 하위클래스(자식 클래스)
		
		is a					- 상속 관계에 있는 클래스를 부르는 용어
		
			예 ]
				
				class Father {
				}
				
				class Son extends Father {
				}
				
				이 경우 Son is a Father 가 성립한다.
				
		has a					- 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			
				class Wook {
				}
				
				class Class15B {
					Wook w = new Wook();
				}
				
					Class15B has a Wook 가 성립한다.
					
------------------------------------------------------------------------------------------

상속관계에 있는 경우 생성자의 역할

	결론적으로
		하위클래스가 생성되는 순간
		(인스턴스가 만들어지는 순간 - new 명령과 함께 생성자가 호출되는 순간)
		상위 클래스의 인스턴스가 자동으로 생성된다.
		
		==> 생성되는 순간 생성자 함수가 호출되므로
			결국 하위 클래스를 생성하면 상위클래스의 생성자함수도 같이 호출된다.
		
	결국 상위 클래스의 생성자함수는 자동으로 호출되는 개념이다.
	자동 호출되는 경우에는 무조건 기본 생성자만 이용하게 된다.

		***
		참고 ]
			super()
			==> 상위클래스의 특별한 생성자를 강제로 호출하는 기능
		
			특징 ]
			
				1. 반드시 생성자함수 안에서만 호출가능
				2. 반드시 생성자함수 안의 첫 줄, 첫 문장으로 호출돼야함.
				
참고 ]
	super - 현재 실행중인 객체의 상위 클래스 인스턴스를 기억하는 변수
			<== 현재 클래스의 객체가 생성되는 순간
				상위 클래스의 인스턴스도 자동 생성되기 때문에
				그 인스턴스의 주소도 기억되어진다.
------------------------------------------------------------------------------------------

*****
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위클래스에서
	상위클래스가 가진 함수의 기능을 수정하는 행위 
	
	방법 ]
		0. 상속을 받아야한다.
		1. 상위 클래스가 가진 함수의 원형(prototype)과 동일한 형태로 만들어야한다.
		
			참고 ] 
				함수의 원형 : 반환값 + 함수이름 + 매개변수리스트
				
			예 ]
				
				public String toString(){} ==> Object 클래스의 멤버
				
				이 함수를 재정의하는 방법
				==>
					public String toString(){
						내용을 수정
					}	===========> 오버라이딩O
					
					public String toString(Object o){
						내용을 수정
					}	===========> 오버라이딩X 오버로딩O
		
		2. 접근지정자는 같거나 넓은 방향으로
			참고 ]
				클래스에 상용가능한 접근지정자는
					public 이거나 생략만
				사용가능.
				
		3. 예외전이는 같거나 좁은 방향으로. (예외처리 수업 후 다시 설명)
		

	이렇게 오버라이딩(함수의 재정의)을 하면 
	내부적으로 super(상위클래스)의 함수는 숨겨지고 재정의한 함수를 사용하게 된다.
	
	예 ]
		class Father {
			void abc(int no){}
		}
		
		class Son extends Father{
			void abc(int no){
				// 코딩 내용을 다르게 작성
				// ==>  기능이 변경된다.
			}
		}	
		
	super
	==> this가 실행중인 자신의 주소를 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나.
		자신의 상위 클래스의 주소가 기억된 변수.
		
		사용목적 ]
			반드시 소속을 밝혀야하는 경우가 발생할 때 사용한다.
			
------------------------------------------------------------------------------------------
		
객체지향언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화		
		
------------------------------------------------------------------------------------------
		
**********
다형성
==> 하나의 변수를 이용해서 
	여러 형태의 클래스를 사용하도록 하는 기법	
	
	주소의 형변환(Casting)
	==> 원칙적으로 주소는 다른 형태로 형변환이 불가능하다.
		즉, 주소는 Heap Type에 따라 주소가 결정되므로
		Heap Type이 다르면 주소는 기억시킬 수 없음.
		
		예 ]
		
			int[] a = new float[5];		--- x
heap type :		int[]		float[]


			float[] = a = new int[5];	--- x
	
	*****	
	상속관계에 있는 클래스들 끼리에 한해서 is a 관계이기 때문에 형변환이 가능하다.		
	==> 하위클래스에는 상위클래스의 멤버가 들어있기 때문.
	
		자동 형변환
		==> 하위 클래스의 주소가 상위 클래스의 변수에 기억될 때는 자동 형변환을 해줌.
		
			예 ]
				class Grand {}
				
				class Father extends Grand{}
				
				class Son extends Father{}
				
				Grand g = new Son();
				Father f = new Son();
				Grand g = new Father();
				
		강제 형변환
		==> 상위 클래스의 주소가 하위 클래스 변수에 기억되는 것은 원칙적으로 불가능,
			다만 강제로 형변환 가능.
			
			예 ]
				Son s = new Father(); == x
				Son s = (Son) new Father(); == o
				
정리 ] 
	다형성이란 
	주소의 형변환 이론을 기반으로 상위클래스의 주소를 애용해서 하위클래스를 이용가능,
	상위 클래스의 주소를 이용하면 여러 하위클래스를 사용가능

참고 ]
	개발자 입장에서의 다형성
		상위클래스의 변수를 이용하면 하위 클래스를 사용할 수 있다.
		
		상위클래스의 변수를 이용해서 하위클래스를 받아서 사용하면 된다.				
		
	참고 ]
		1. 어떤 함수가 상위클래스를 매개변수로 가지고 있으면
		
			예 ]
				void abc(Figure f){
				
				}
				abc(new Semo()); // Figure f = new Semo(); ==> 상속자의 자동형변환
				
				abc(new Won());
				abc(new Nemo());
				
				참고 ] 
					매개변수
					
					void xyz(int a){}
					
					xyz(10); ==> int a = 10; // 내부적으로 처리해서 실행
					
					xyz('A'); ==>29 int a = 'A';
					
			따라서 만약 어떤 함수가 Object를 매개변수로 가지고 있으면
			Object를 주는 경우는 없다.
			대신 자바에서 사용할 수 있는 모든 데이터를 입력해도 된다.
		
		2. 어떤 함수가 상위클래스를 반환값 타입으로 가지고있으면
			반드시 원하는 하위클래스 타입으로 강제 형변환 해서 사용해야함.
			
				
			참고 ]
				Wrapper Class 
				==> 객체가 아닌 기본 데이터타입을
					객체처럼 사용해야될 경우가 발생하기 때문에
					자바에서 기본 데이터탑을 객체형태로 사용할 수 있도록 만들어놓은 클래스들
					
					Boolean
					
					Character
					
					Byte
					Short
					Integer
					Long
					
					Float
					Double
				
			참고 ]
			Boxing
			==> 기본 데이터 타입을 객체 타입으로 변환하는 작업
			
			UnBoxing
			==> 객체타입을 기본 데이터 타입으로 변환하는 작업
			
			참고 ]
				컬렉션에 모아서 사용할 데이터의 타입을 정할 수 있는데
				이 때는 기본 데이터타입을 기술하면 안됨.
				이 때는 Wrapper 클래스 타입으로 기술해야한다
				
				Array list = new ArrayList();
				
				
				
				
				
				
				
				
				
				
				
				
				
		
		
		
		
		
		
		
		