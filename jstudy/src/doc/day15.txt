#day15 

가변인자
==> 함수를 제작할 때 
	그 함수가 가지고 있는 매개변수와 동일한 개수, 형태, 순서를
	이용해서 함수를 호출해야한다. 
	
	==>
		void abc(int a, int b){}
		
		==> 
			abc(1,2);		==== O
			
			abc(); 			==== X
			abc(1);			==== X
			abc(3.14);		==== X
			abc(10,3.14);	==== X
		
	만약 데이터의 개수를 지정할 수 없을 경우 "가변 인수"
	
		데이터의 개수에 상관없이
		모든데이터를 입력받을 수 있도록 할 수 있다.
	
	형식 ]
	
		[접근지정자]반환값타입		함수이름(타입 ... 변수이름){
			처리내용
		}
		
		예 ]
			void abc(int ... num){
				// 이렇게 함수를 만들면 
				// 이제는 데이터의 개수에 상관없이
				// 데이터를 입력받아서 이 함수를 호출할 수 있다.
			}
			
			abc(10, 20); 		==== O
			abc(1,2,3,4,5); 	==== O
			
	*
	주의 ]
		이 때 가변인수 변수(num)는 자동 배열 변수가 된다.
		따라서 데이터 사용도 배열에서 처리하는 방식으로 사용해야된다.
		
	주의 ]
		가변인수 앞에는 다른 매개변수가 와도 상관없음.
			예 ]
			
				void abc(int a, int ... no){} === O
				
		가변인수 뒤에는 다른 매개변수가 오면 안된다.
			예 ]
				
				void abc(int ... no, int a){} === X
				
-------------------------------------------------------------------------------------------------								

참고 ]
	생성자
	==> 클래스를 사용하기위해 객체를 만들 때 호출되는 함수
	new 명령과 같이 호출되는 함수
	
		예 ]
			
			class Abc{
				public int num = 10;
				private int no;
				public int getNo(){
					retrun no;
				}
				public void setNo(int no){
					this.no = no;
				}
			}
	
	이 경우 Abc 클래스의 no의 값을 꺼내서 사용하려면
	
	1. 객체를 만든다.
		Abc a1 = new Abc();
		
	2. 주소를 통해서 멤버에 접근한다.
		int no = a1.getNo();
		
-------------------------------------------------------------------------------------------------								
this
==> 현재 실행 중인 객체의 주소를 기억하는 약속된 변수

	이것은 JVM이 클래스를 처리하기 위해서 
	JVM이 사용하는 변수
	따라서 개발자는 거의 이 변수를 사용하지 않는다.
	
	규칙 ]
	
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야한다.
			멤버는 클래스 안에 만들어진 변수나 함수를 부르는 단어
			
			new 시킨 후 그 주소를 기억해 노았다가
			그 주소를 이용해서 사용
			
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여줌.
		
		3. 멤버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속했고
			함수는 this 변수를 준비한 후 
			함수를 호출할 때 알려준 주소를 기억하게 된다.
			
	참고 ]
		딱 한번 this를 개발자가 사용해야 하는 경우가 있다.
		
		가끔은 지역변수와 멤버변수가 이름이 동일하게 만드는 경우가 발생한다.
		이 경우 그 함수는 지역 변수가 우선 사용하게됨. 
		따라서 멤버 변수에는 데이터가 기억되지 않을 수 있다.
		
		***
		이 떄
			굳이 이 변수가 멤버 변수임을 
			반드시 밝히고 싶지 않은 경우가 생기면
			이 때 강제로 this라고 붙여주면 된다.
			
-------------------------------------------------------------------------------------------------								

멤버변수의 초기화
==> 멤버변수는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화 
		==> 변수를 선언하면서 값을 입력하는 방법
			가장 먼저 실행되는 방법
			
			예]
				class Test{
					int no = 10; //==> 명시적 초기화
				}
	2. 초기화 블럭을 이용한 초기화
		==> 이것은 인스턴스 변수에 대해서만 가능
			두번째로 실행되는 방법
			
			방법 ]
				{
					이 안에 데이터를 변수에 대입
				}
				
				예 ]
					class Test{
						int n = 100;
						{
							no = 10;
						}
					}
					==> 결과적으론 no = 10; 으로 초기화
					
	3. static 블럭을 이용한 초기화
		==> 2번과 비슷하지만 static 변수에 한해서만 가능
			두번째로 실행되는 방법
			
			형식 ]
			
				static{
					static 변수 데이터 입력...
				}
			
			예 ]
			
				class Test {
					int no;
					static int num;
					{
						no = 10;
					}
					
					static {
						num = 100;
					}
				}
				
	4. 생성자함수를 이용한 초기화
		가장 마지막에 실행되는 방법
		
		예 ]
			class Test{
				int no;
				
				public Test(){
					no = 10;
				}
				
				public test(int no){
					this.no = no;
				}
			}
---------------------------------------------------------------------------------

객체 지향 언어의 특징
	
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화
	
***
은닉화
==> 프로그램에 있어서 가장 중요한 요소는 데이터이다.
	즉, 변수가 프로그램의 핵심적인 요소가 된다.
	무결성 데이터를 유지할 수 있는 것이 
	가장 핵심적인 개념이 된다.
	
	은닉화란?
	이렇게 중요한 요소인 변수를 
	사용자가 함부로 변경하지 못하도록
	(결함이 있는 데이터가 입력되지 못하도록 하는것)
	방지하는 기술을
		"은닉화"
	라 한다.
	
	방법 ]
		1. 중요한 데이터가 기억될 변수는 private 으로 처리한다.
			==> 해당 변수는 다른 사용자가 사용할 수 없게 된다.
				다른 클래스에서도 접근 할 수 없게 된다.
				
		2. 대신 이 변수의 값을 변경하거나, 값을 꺼내는 작업은
			함수를 이용해서 처리한다.
			
캡슐화
==> 이렇게 은닉화된 변수들을 하나로 합쳐서 (캡슐처럼 모아서)
	한꺼번에 전달 하거나 기억하는 작업