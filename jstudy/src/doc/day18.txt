# day18

JDBC
==> 자바 프로그램을 이용해서 데이터베이스를 컨트롤 할 수 있는 외부 API이다.

	데이터베이스는 그 데이터베이스가 가진 DBMS에 의해 성능이 결정됨.
	각각의 데이터베이스 마다 질의 명령을 처리하는 방법(DBMS)이 다르다는 것.
	따라서, 개발자 입장에서 데이터베이스마다 그 데이터베이스의 DBMS에 따라
	프로그램 방식을 다르게 해야한다.
	
	해결방법 ]
		
		자바 내에 DBMS를 생성, 개발자는 자바의 DBMS에게만 명령을 전달하도록 해 놓음.
		==>
			개발자는 한 가지 방식으로만 처리하도록 됨.
		자바안에 있는 DBMS가 실제 데이터베이스와 연결해서 처리하도록 해놓았다.
		
		이 때 자바 DBMS가 바로 JDBC이다.
		
		따라서
		우리가 JDBC를 배운다는 것은
		우리는 JDBC에게만 명령을 전달하면(한 가지 방식으로 명령을 전달하면)
		JDBC가 알아서 필요한 데이터베이스의 DBMS에게 명령을 전달 하게 됨.
		
참고 ]
	JDBC와 각 밴더 DBMS를 연결하는 프로그램은
	그 데이터스를 만든 회사에서 제공.
	
***
자바 개발자(데이터베이스 처리를 해야하는)가 가장 먼저 해야할 일

	1. 사용하려는 데이터베이스와 JDBC를 연결하는 프로그램 탐색.
		이 프로그램을
			"JDBC Driver"
		라고 부른다.
	
	2. 탐색한 외부 API를 이클립스에 등록해서 이클립스에서 외부 API를 사용할 수 있도록 설정.
		(외부 라이브러리 등록 방법)
		
		1) 프로젝트 선택 - ALT+ENTER(PROPERTIES)
		2) Java Build Path 메뉴선택
		3) Libraries 선택
		4) Add External JARs 클릭 - 다운로드한 드라이버 파일을 선택.
		
참고 ]
	인터페이스로 만들어 놓은 이유 
	==> 세션을 관리하는 방법이 각각의 DBMS마다 다르기 때문에
		접속하는 순간 함수의 기능을 각각의 DBMS에 맞도록 조절해야한다.
		
JDBC 프로그램 정리 ]
	0. JDBC 드라이버를 구비.
	
	1. 드라이버를 로딩.
		(예 ] SmartJDBC 의 생성내의 Class.forName() )
	2. 데이터베이스에 접속.
		Connection con = DriverManager.getConnection(); <== getCon()
	3. JDBC와 실제 DBMS사이에 명령을 전달할 수 있는 도구를 생성.	
		(
			오라클은  데이터베이스 서버이다.
			즉, 프로그램이 동작하는 컴퓨터와 데이터베이스가 있는 컴퓨터는 다를 수 있다.
		)
		
		사용하는 인터페이스
			Statement
			
		만드는 방법
			Statement stmt = con.createStatement();
		
			참고 ]
				질의명령을 실행하는 방법(Statement에 질의명령을 실어서 보내는 방법)
				
					1. execute(String sql)
						==> 질의명령을 실행 후 JDBC에게 보고하지 않음.
							반환값 타입은 bloolean 타입,
							이것은 질의실행여부를 알려주는 기능이 아니고
							데이터베이스가 JDBC에게 명령받았는지만 알려줌.
							
							이 반환값은 질의 실행 여부와는 전혀 상관이 없는 반환값.
							
					2. executeQuery(String sql)
						==> 반환값 타입이 ResultSEt
							질의명령의 실행결과 탄생하는 인라인 테이블을 관리하는 클래스
							
							100% SELECT 질의명령에 사용되어야 함.
							
					3. executeUpdate(String sql)
						==> 반환값 타입이 int 
							반환값 타입의 의미는 질의명령 실행결과
							변경된 행의 (데이터) 숫자
							
							예 ] 
								UPDATE 	했는데 몇 개의 행이 변경되었는지
								DELETE 	했는데 몇 개의 행이 삭제되었는지
								INSTERT 했는데 몇 개의 행이 추가되었는지
							
							주로 질의명령의 실행결과 여부를 판단해야할 경우에 사용하는 함수
							
								INSERT, UPDATE, DELETE
								
						
				참고 ]
					질의명령은 위 세 함수를 아무것이나 사용해도 상관없음.
		
-----------------------------------------------------------------------------------------

SELECT 질의 결과 사용하기

	JDBC에서 SELECT 질의명령을 보내면
	그 결과 인라인 테이블이 생성되고
	ResultSet 이라는 인터페이스 타입의 객체가
	그 결과를 관리하도록 하고있다.
	
	ResultSet 이라는 인터페이스를 이용해서
	인라인테이블의 결과 중에서 필요한 데이터를 선택하여 사용가능
	
	인라인 테이블의 결과 중에서 원하는 데이터를 꺼내는 방법 ]
	
		현재 작업줄(행)의 몇 번째 칸(필드) 또는 어떤(필드이름) 칸을 꺼내주세요 라고 요청해야함		
			작업진행줄 : 레코드포인터 라고 말한다.
			
		주요함수 ]
		
			1. 가상의 레코드포인터(현재 작업 위치) 를 이동시켜주는 명령
			
				absolute(int row)
				==> 지정한 행으로 즉시 이동
				
				afterLast()
				==> EOF로 즉시 이동
				
				beforeFirst()
				==> BOF로 즉시 이동
				
				first()
				==> 첫 행으로 즉시 이동
				
				last()
				==> 끝 행으로 즉시 이동
				
				next()
				==> 현재위치의 다음 행으로 이동, 
					반환값 타입은 boolean(이동결과 꺼낼 데이터가 있는지 여부)
		
			주의 ]
				afterLast()		== EOF
				beforeFirst()	== BOF
				==> 항상 이동에 성공하게 된다.
					EOF, BOF 는 인라인테이블이 생성되면
					자박 자동으로 만들어주는 가상의위치, 언제나 존재함.
					
				이들 이외의 함수들은 이동에 실패할 수 있다.
		
			2. 데이터를 꺼내는 함수
			
				getXXXXX()
				==> XXXXX는 꺼낼 데이터를 사용할 데이터 타입		
					--> 실제 데이터베이스에 있는 타입이 아니고
						그 데이터를 사용할 자바에서의 타입을 의미
						==> 데이터베이스에 있는 타입과 달라도 상관없음.
							
					참고 ] 
						데이터 베이스에서는 문자와 문자열을 
						구분하지 않기 때문에 getChar() 라는 함수는 없음.
						
				주의 ]
					꺼내는 방식
					
						1. getXXXXX(int 컬럼위치)
							==> 질의명령에서 나열된 필드의 위치값을 사용.
							
								자바는 위치값(인덱스)을 0부터 시작하지만
								데이터베이스는 1부터 시작한다.
								
								예 ]
									SELECT
										empno, enmae, job jikgeop
									FROM
										emp
									==>
										getString(3) == > job 꺼내는 법
									
						2. getXXXXX("필드이름")
							==>
								getString("job") == > 필드이름으로 꺼내는 법
								
								별칭이 붙은 경우는 인라인테이블의 필드이름이 
								별칭으로 만들어지기 때문에 별칭으로 꺼내야함
								
								getString("jikgeop")
								
						주의 ]
							Date 타입 데이터는 꺼내오는 함수를 JDBC에서 
							날짜만 꺼내는 함수와 시간만 꺼내는 함수가 있음.
							따라서 정확한 날짜 데이터를 꺼내려면
							한 필드에서 날짜와 시간을 각각 꺼내와야함.
							
								날짜 - getDate("필드이름")
								시간 - getTime("필드이름")
		
----------------------------------------------------------------------------------------

양방향 이동가능한 인라인 테이블 만드는 방법
==> 
	Statement 가 양방향 스테이트먼트가 되어야한다.
	
	createStatement(int resultSetType, int resultSetConcurrency)
	를 이용해서 Statement를 생성해야 양방향 인라인 테이블이 만들어진다.				
	
		int resultSetType
			
			ResultSet.TYPE_FORWARD_ONLY
			==> 기본값으로 전前방향 인라인테이블을 만들어준다.
			
			ResultSet.TYPE_SCROLL_INSENSITIVE
			==> 양방향 인라인 테이블을 만들어준다.
				저장된 데이터를 반복해서 작업하는동안
		
			ResultSet.TYPE_SCROLL_SENSITIVE
			==> 양방향 인라인 테이블을 만들어준다.
				데이터의 변경을 적용시킨다.
			
		int resultSetConcurrency	- 동시성 설정
		
			ResultSet.CONCUR_READ_ONLY
			==> ResultSet의 데이터를 읽기전용, 업데이트 불가능
			
			ResultSet.CONCUR_UPDATABLE
			==> 업데이트 가능
		
	참고 ]
		JDBC는 UPDATE, DELETE, INSERT 명령을 실행하지않고
		직접 데이터를 수정할 수 있다.
		
----------------------------------------------------------------------------------------
		
PreparedStatement		
==> 질의명령을 데이터베이스에 전달하는 Statement의 일종이다.
	
	Statement의 단점은
	질의명령을 실행할 때 마다 매번 질의명령을 데이터베이스에게 전달하는 형식을 취한다.
	
	그런데 질의명령이 긴 경우도 존재.
	
	데이터베이스는 네트워크를 이용하고있고 따라서 명령전달하는데 시간이 걸린다던지		
	이런 문제점을 해결하기 위한 Statement가 PrepareStatement이다.
	
	미리 질의명령을 알려준 후 실행이 필요하면 실행만 해달라고 요청하는 형식.
	
	만드는 방법 ] 
	
		con.prepareStatement();
		
	참고 ]
		자주 사용하는 질의명령이라도 데이터는 달라질 수 있다.
		이런 경우는
		질의명령을 만들 때 변화되는 부분은  ?로 대신하면 된다.
		
		?부분만 질의명령을 실행하기전에 직접 데이터로 채워서 
		질의명령을 완성한 후 전달하는 방식
		
		예 ]
			
			회원의 아이디를 알려주면 메일을 알려주는 질의명령
			==>
				String sql = "SELECT mail FROM member WHERE id = ?";
				
				PreparedStatement pstmt = con.prepareStatement(sql); 
				
		주요함수 ]
			?를 채워주는 함수
			
			setXXXXX(위치, 데이터);
			
			XXXXX 	: 채울 데이터의 형태에따라 달라진다.	
			위치	: ?의 위치 (몇 번째 ?인지 기술한다.)
			데이터	: 채울 데이터
			
			예 ]
			
				pstmt.setString(1,"jennie");
		
참고 ]
	Statement는 속도는 느리지만 
	매번 다른 질의명령을 처리할 수 있다.
	
	PreparedStatement는 속도는 빠르지만
	항상 동일한 질의명령만 처리할 수 있다.		
		
==================================================================================
StringBuffer
==> String 클래스와 마찬가지로 문자열을 관리하는 클래스

	*****
	차이점
		String은 내용이 변환되면 새로운 메모리를 다시 확보,
		변화된 내용은 다시 기억한 후 주소를 바꾼다.
		==> 자주 변화가 일어나면 메모리 낭비가 심해진다.
		
		이런 문제점을 해결하기 위해 만들어진
		또 하난의 문자열 관리 클래스 StringBuffer.
		
		내용의 변화가 있으면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
	참고 ]
		String str = "홍";
		==> String은 너무 빈번하게 사용되는 클래스이므로
			클래스들 중 유일하게 데이터를 직접 대입할 수 있도록
			자바가 유일하게 허락한 문법.
		
		StringBuffer는 String 클래스와는 달리 대입연산자 = 를 이용해서 
		문자열을 기억하는 것이 불가능함
		반드시 객체지향원리에 따라서 new시켜서 사용해야함.
		
		예 ]
			StringBuffer buff = "jennie";					//안됨
			StringBuffer buff = new StringBuffer("jennie");	//됨

	참고 ] 
		String str = "Hong";
		str = str + "Gildong";
		
		즉, 결합연산자를 이용한 문자열을 결합하는 것 역시
		String클래스에 한해서만 허락된 문법.
		
		나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를 이용해서
		필요한 처리를 해줘야한다.
		
		StringBuffer buff = new StringBuffer("Hong");
		buff.append("Gildong");
		
	사용하는 방법 ]
		
		1. String으로 먼저 변수를 만든다.
			
			String str = "Hong";
			
		2. 문자열 변화가 필요한 시점에서
			StringBuffer로 변환시켜준다.
			
			StringBuffer buff = new StringBuffer(str);
			
		3. StringBuffer를(내무의 함수를이용) 이용해서 문자열을 조작한다.
			
			buff.append("Gil");
			buff.append("Dong");
			
		4. 문자열의 조작이 완료되면 String타입으로 다시 변환시켜야한다.
		
			str = buff.toString();

참고 ]
	StringBuilder
	==> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스
	
		주로 Thread(쓰레드)처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.
		
------------------------------------------------------------------------------------

StringTokenizer
==> 하나의 문자열을 원하는 문자를 중심으로 나누어주는 기능을 가진 클래스

	네트워크 등을 이용하면
	동시에 여러개의 데이터를 한번에 전달받게 된다.
	
	예 ]
		카톡의 경우 
		각각의 데이터를 분리해서 처리해야한다.
		보낸사람@보낸시간@내용
		
	생성자 ]
	
		1. StringTokenizer(String str)
			==> 문자열(str)을 공백을 ㄱ구분자로 나누는 기능
			
		2. StringTokenizer(String str, String delim)
		=	==> 문자열(str)을 지정한 문자열(delim)을 기준으로 나누는 기능
		
		3. StringTokenizer(String str, String delim, boolean returnDelims)
		==> 2번 + 분리문자도 하나의 문자로 처리한다.

	주의 ]
		분리된 결과는 임시버퍼(스택)에 기억된다.
		따라서 이것은 한 번 사용하면 더 이상 사용할 수 없음.
		반드시 순서대로만 꺼내야한다.
		
	주요함수 ]
		countTokens()
		==> 나눈 결과 수를 반환
		
		hasMoreElements() / hasMoreTokens()
		==> 버퍼에 꺼낼 데이터가 남아있는지를 묻는 함수
		
		nextElement()
		==> 데이터를 Object 타입으로 꺼내는 함수
		nextToken()
		==> 데이터를 String 타입으로 꺼내는 함수

========================================================================================

컬렉션(Collection)
==> 많은 양의 데이터를 쉽게 보관할 수 있는 클래스들의 집합

	배열을 이용해서도 많은 양의 데이터를 보관할 수 있지만
	배열의 단점은 
		1. 크기를 변경이 불가능.
		
		2. 데이터의 입출력에 많은 제약을 받는다.
		
	이런 단점을 보완하고자 만들어진 클래스들이 컬렉션.
	
종류 ]
	
	1. List 계열	
		
		특징 ]
			1) 입력순서를 보장. (처리속도가 느림)
			2) 중복데이터의 입력을 허락한다.
						
	2. Set 계열
		
		특징 ]
			1) 입력순서를 보장하지 않음.
				(Set의 규칙에 의해서 데이터를 정렬하여 보관)
			2) 중복데이터의 입력을 허락하지 않는다.		
			
		참고 ]
			Set 계열은 데이터를 꺼내는 함수가 없음
			
	-----------------------------	
	3. Map 계열
		
		특징 ]
			1) 데이터를 키값과 한 쌍을 만들어서 저장.
			2) 입력순서를 보장하지 않는다.
			3) 같은 키값으로 데이터가 입력되면 먼저 입력된 데이터를 삭제.
				(즉, 데이터는 중복되도 상관없지만, 키값은 중복으로 입력불가능)

참고 ] 
	List계열과 Set계열은 같은 상위클래스를 가지고 있다.
	Map계열은 상위클래스가 다름.
	따라서, List계열과 Set계열은 다형성 처리가 가능하지만 (서로 형변환이 가능)
	Map계열은 독립적이므로 변환이 불가능하다.

========================================================================================
List계열
1. Vector
	==> 내부적으로 배열형태를 만들어서 데이터를 보관하는 컬렉션의 일종
	
		장점 ] 
			입력속도와 검색속도가 빠름.
			
		단점 ]
			중간에 데이터를 삽입하거나, 데이터를 삭제하는 속도는 느림.
			
		결론적으로 데이터의 변화가 거의 없는 프로그램에서 많이 사용됨.
		
	생성자 ]
		1) Vector()
			==> 배열의 크기를 10으로 정한 상태로 벡터를 생성
				물론 데이터가 많으면 크기는 변경됨.(2배로)
				
		2) Vector(collection c)
			==> 다른 컬렉션 데이터를 복사해서 벡터를 생성
			
		3) Vector(int initialCapacity)
			==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
			
		4) Vector(int initialCapacity, int capacityIncrement)
			==> 3)번 + 데이터의 양이 초과될 때 늘어나는 크기를 정하면서 벡터를 생성
		
		참고 ]
			컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력받을 수 있다.
			이 때 데이터를 입력받을 공간을 확보해야 되는데
			공간을 확보하는 규칙은
				현재공간 * 2 
			로 확보한다.
			
	주요함수 ]
		1. 데이터를 입력하는 함수
			add(Object e) 
			==> 매개변수가 Object 타입이므로 입력데이터는 Object타입으로 자동형변환됨
				==> 자바에서 사용하는 모든 데이터 입력 가능.
				
			add(int idex, Object element)
				==> 입력될 위치를 정해서 입력
			addAll(Collection c)
			addAll(int index, Collection c)
			addElement(Object obj)
			addElement(Object obj, int index)
			
		2. 데이터를 꺼내는 함수
			get(int index)
			elementAt(int index)
			firstElement()
			lastElement()
			elements()
			
		3. 데이터를 수정하는 함수
			set(int index, Object element)
			setElementAt(Object obj, int index)
			
참고 ]
	E, V, K 라고 표현되어있는 것 들은 Object를 의미하는 제네릭스 용어임.
	
------------------------------------------------------------------------------
ArrayList
==> Vector의 신버전
	배열 형태로 데이터를 관리하기 때문에
	Vector의 특징을 그대로 가진다.
	Thread(쓰레드)처리에서 동기화 처리를 자동으로 해줌으로
	Vector보다는 ArrayList를 선호하는 경향이 있다.
	
	사용방법 역시 Vector와 유사함
	
	참고 ]
		List 계열의 주소를 출력하면
		마치 데이터가 출력되는 것처럼 보이지만 해당 클래스에서 
		Object클래스를 상속받은 toString() 함수를 
		오버라이딩 해놓았기 때문에 내용을 출력해주는 것.
		==> 데이터를 꺼내온 것이 아닌 상태.
		
		List계열을 사용할 때는 반드시 반복문으로 하나씩 꺼내서 사용해야함
		
	

























		